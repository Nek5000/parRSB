/* Custom types used in the codes:
 * - uint
 * - ulong
 * - scalar
 * - BLK_SIZE
 */

@kernel void zero(scalar *p, const uint n) {
  for (int i = 0; i < n; i++; @tile(BLK_SIZE, @outer, @inner)) {
    p[i] = 0.0;
  }
}

@kernel void copy(scalar *v, scalar *u, const uint n) {
  for (int i = 0; i < n; i++; @tile(BLK_SIZE, @outer, @inner)) {
    v[i] = u[i];
  }
}

@kernel void addc(scalar *v, const scalar alpha, const uint n) {
  for (int i = 0; i < n; i++; @tile(BLK_SIZE, @outer, @inner)) {
    v[i] = v[i] + alpha;
  }
}

@kernel void sum(const uint n, const scalar *v, scalar *blk_sum) {
  for (int i = 0; i < (n + BLK_SIZE - 1) / BLK_SIZE; i++; @outer) {
    @shared scalar s[BLK_SIZE];

    for (int j = 0; j < BLK_SIZE; j++; @inner) {
      int t = i * BLK_SIZE + j;
      if (t < n) {
        s[j] = v[t];
      } else {
        s[j] = 0.0;
      }
    }

    @barrier("warp");

    for (int k = (BLK_SIZE + 1) / 2; k > 0; k /= 2) {
      for (int j = 0; j < BLK_SIZE; j++; @inner) {
        if (j < k) {
          s[j] += s[j + k];
        }
      }
    }

    @barrier("warp");

    for (int j = 0; j < BLK_SIZE; j++; @inner) {
      if (j == 0) {
        blk_sum[i] = s[0];
      }
    }
  }
}

@kernel void norm(scalar *blk_sum, const uint n, const scalar *a) {
  for (int i = 0; i < (n + BLK_SIZE - 1) / BLK_SIZE; i++; @outer) {
    @shared scalar s[BLK_SIZE];

    for (int j = 0; j < BLK_SIZE; j++; @inner) {
      int t = i * BLK_SIZE + j;
      if (t < n)
        s[j] = a[t] * a[t];
      else
        s[j] = 0.0;
    }

    @barrier("warp");

    for (int k = (BLK_SIZE + 1) / 2; k > 0; k /= 2) {
      for (int j = 0; j < BLK_SIZE; j++; @inner) {
        if (j < k)
          s[j] += s[j + k];
      }

      @barrier("warp");
    }

    for (int j = 0; j < BLK_SIZE; j++; @inner) {
      if (j == 0)
        blk_sum[i] = s[0];
    }
  }
}

@kernel void dot(scalar *blk_sum, const uint n, const scalar *a,
                 const scalar *b) {
  for (int i = 0; i < (n + BLK_SIZE - 1) / BLK_SIZE; i++; @outer) {
    @shared scalar s[BLK_SIZE];

    for (int j = 0; j < BLK_SIZE; j++; @inner) {
      int t = i * BLK_SIZE + j;
      if (t < n)
        s[j] = a[t] * b[t];
      else
        s[j] = 0.0;
    }

    @barrier("warp");

    for (int k = (BLK_SIZE + 1) / 2; k > 0; k /= 2) {
      for (int j = 0; j < BLK_SIZE; j++; @inner) {
        if (j < k)
          s[j] += s[j + k];
      }

      @barrier("warp");
    }

    for (int j = 0; j < BLK_SIZE; j++; @inner) {
      if (j == 0)
        blk_sum[i] = s[0];
    }
  }
}

@kernel void scale(scalar *v, const uint start, scalar *u, const scalar alpha,
                   const uint n) {
  for (int i = 0; i < n; i++; @tile(BLK_SIZE, @outer, @inner)) {
    v[start + i] = alpha * u[i];
  }
}

@kernel void add2s1(scalar *p, const scalar *r, const scalar beta,
                    const uint n) {
  for (int i = 0; i < n; i++; @tile(BLK_SIZE, @outer, @inner)) {
    p[i] = beta * p[i] + r[i];
  }
}

@kernel void add2s2(scalar *p, scalar *r, const scalar alpha, const uint n) {
  for (int i = 0; i < n; i++; @tile(BLK_SIZE, @outer, @inner)) {
    p[i] = p[i] + alpha * r[i];
  }
}

@kernel void laplacian_v00(scalar *y, const uint nr, const uint *offsets,
                           const scalar *v, const scalar *x) {
  for (int i = 0; i < nr; i++; @tile(BLK_SIZE, @outer, @inner)) {
    scalar s = 0.0;
    for (int j = offsets[i]; j < offsets[i + 1]; j++)
      s += v[j] * x[j];
    y[i] = s;
  }
}
