/* Custom types used in the codes:
 * - uint
 * - ulong
 * - scalar
 * - BLK_SIZE
 */

@kernel void zero(scalar *p, const uint n) {
  for (int i = 0; i < n; i++; @tile(BLK_SIZE, @outer, @inner)) {
    p[i] = 0.0;
  }
}

@kernel void copy(scalar *v, scalar *u, const uint n) {
  for (int i = 0; i < n; i++; @tile(BLK_SIZE, @outer, @inner)) {
    v[i] = u[i];
  }
}

@kernel void addc(scalar *v, const scalar alpha, const uint n) {
  for (int i = 0; i < n; i++; @tile(BLK_SIZE, @outer, @inner)) {
    v[i] = v[i] + alpha;
  }
}

@kernel void sum(const uint n, const scalar *v, scalar *blk_sum) {
  for (int i = 0; i < (n + BLK_SIZE - 1) / BLK_SIZE; i++; @outer) {
    @shared scalar s[BLK_SIZE];

    for (int j = 0; j < BLK_SIZE; j++; @inner) {
      int t = i * BLK_SIZE + j;
      if (t < n) {
        s[j] = v[t];
      } else {
        s[j] = 0.0;
      }
    }

    @barrier("warp");

    for (int k = (BLK_SIZE + 1) / 2; k > 0; k /= 2) {
      for (int j = 0; j < BLK_SIZE; j++; @inner) {
        if (j < k) {
          s[j] += s[j + k];
        }
      }
    }

    @barrier("warp");

    for (int j = 0; j < BLK_SIZE; j++; @inner) {
      if (j == 0) {
        blk_sum[i] = s[0];
      }
    }
  }
}

@kernel void norm(scalar *blk_sum, const uint n, const scalar *a) {
  for (int i = 0; i < (n + BLK_SIZE - 1) / BLK_SIZE; i++; @outer) {
    @shared scalar s[BLK_SIZE];

    for (int j = 0; j < BLK_SIZE; j++; @inner) {
      int t = i * BLK_SIZE + j;
      if (t < n)
        s[j] = a[t] * a[t];
      else
        s[j] = 0.0;
    }

    @barrier("warp");

    for (int k = (BLK_SIZE + 1) / 2; k > 0; k /= 2) {
      for (int j = 0; j < BLK_SIZE; j++; @inner) {
        if (j < k)
          s[j] += s[j + k];
      }

      @barrier("warp");
    }

    for (int j = 0; j < BLK_SIZE; j++; @inner) {
      if (j == 0)
        blk_sum[i] = s[0];
    }
  }
}

@kernel void dot(scalar *blk_sum, const uint n, const scalar *a,
                 const scalar *b) {
  for (int i = 0; i < (n + BLK_SIZE - 1) / BLK_SIZE; i++; @outer) {
    @shared scalar s[BLK_SIZE];

    for (int j = 0; j < BLK_SIZE; j++; @inner) {
      int t = i * BLK_SIZE + j;
      if (t < n)
        s[j] = a[t] * b[t];
      else
        s[j] = 0.0;
    }

    @barrier("warp");

    for (int k = (BLK_SIZE + 1) / 2; k > 0; k /= 2) {
      for (int j = 0; j < BLK_SIZE; j++; @inner) {
        if (j < k)
          s[j] += s[j + k];
      }

      @barrier("warp");
    }

    for (int j = 0; j < BLK_SIZE; j++; @inner) {
      if (j == 0)
        blk_sum[i] = s[0];
    }
  }
}

@kernel void scale(scalar *v, const uint start, const scalar *u,
                   const scalar alpha, const uint n) {
  for (int i = 0; i < n; i++; @tile(BLK_SIZE, @outer, @inner)) {
    v[start + i] = alpha * u[i];
  }
}

@kernel void add2s1(scalar *p, const scalar *r, const scalar beta,
                    const uint n) {
  for (int i = 0; i < n; i++; @tile(BLK_SIZE, @outer, @inner)) {
    p[i] = beta * p[i] + r[i];
  }
}

@kernel void add2s2(scalar *p, scalar *r, const scalar alpha, const uint n) {
  for (int i = 0; i < n; i++; @tile(BLK_SIZE, @outer, @inner)) {
    p[i] = p[i] + alpha * r[i];
  }
}

@kernel void laplacian_v00(scalar *y, const uint nr, const uint *adj_off,
                           const uint *adj_ind, const scalar *adj_val,
                           const uint *diag_ind, const scalar *diag_val,
                           const scalar *x) {
  for (int i = 0; i < nr; i++; @tile(BLK_SIZE, @outer, @inner)) {
    scalar s = diag_val[i] * x[diag_ind[i]];
    for (int j = adj_off[i]; j < adj_off[i + 1]; j++) {
      s = s + adj_val[j] * x[adj_ind[j]];
    }
    y[i] = s;
  }
}

@kernel void laplacian_v01(scalar *y, const uint nr, const uint *adj_off,
                           const uint *adj_ind, const sint *adj_val,
                           const uint *diag_ind, const sint *diag_val,
                           const scalar *x) {
  for (int i = 0; i < nr; i++; @tile(BLK_SIZE, @outer, @inner)) {
    scalar s = diag_val[i] * x[diag_ind[i]];
    for (int j = adj_off[i]; j < adj_off[i + 1]; j++) {
      s = s + adj_val[j] * x[adj_ind[j]];
    }
    y[i] = s;
  }
}

@kernel void laplacian_v02(scalar *y, const uint nr, const uint *adj_off,
                           const uint *adj_ind, const short *adj_val,
                           const uint *diag_ind, const short *diag_val,
                           const scalar *x) {
  for (int i = 0; i < nr; i++; @tile(BLK_SIZE, @outer, @inner)) {
    scalar s = diag_val[i] * x[diag_ind[i]];
    for (int j = adj_off[i]; j < adj_off[i + 1]; j++) {
      s = s + adj_val[j] * x[adj_ind[j]];
    }
    y[i] = s;
  }
}

@kernel void laplacian_v03(scalar *y, const uint nr, const uint *adj_off,
                           const uint *adj_ind, const short *adj_val,
                           const uint *diag_ind, const scalar *x) {
  for (int i = 0; i < nr; i++; @tile(BLK_SIZE, @outer, @inner)) {
    scalar s = 0;
    int d = 0;
    for (int j = adj_off[i]; j < adj_off[i + 1]; j++) {
      short t = adj_val[j];
      d = d + t;
      s = s + t * x[adj_ind[j]];
    }
    y[i] = s - d * x[diag_ind[i]];
  }
}

@kernel void laplacian_v04(scalar *y, const uint nr, const uint *adj_off,
                           const uint *adj_ind, const signed char *adj_val,
                           const uint *diag_ind, const short *diag_val,
                           const scalar *x) {
  for (int i = 0; i < nr; i++; @tile(BLK_SIZE, @outer, @inner)) {
    scalar s = diag_val[i] * x[diag_ind[i]];
    for (int j = adj_off[i]; j < adj_off[i + 1]; j++) {
      int t = adj_val[j];
      s = s + t * x[adj_ind[j]];
    }
    y[i] = s;
  }
}

@kernel void laplacian_v05(scalar *y, const uint nr, const uint *adj_off,
                           const uint *adj_ind, const signed char *adj_val,
                           const uint *diag_ind, const scalar *x) {
  for (int i = 0; i < nr; i++; @tile(BLK_SIZE, @outer, @inner)) {
    scalar s = 0;
    char d = 0;
    for (int j = adj_off[i]; j < adj_off[i + 1]; j++) {
      int t = adj_val[j];
      d = d + t;
      s = s + t * x[adj_ind[j]];
    }
    y[i] = s - d * x[diag_ind[i]];
  }
}
